import socket
import struct

# Создание сокета TCP для сервера
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind(('localhost', 5020))  # Привязываем сокет к адресу и порту
server_socket.listen(1)  # Ожидаем одно соединение

print("Ждем соединения с клиентом...")

# Принятие соединения от клиента
client_socket, client_address = server_socket.accept()
print(f"Соединение установлено с клиентом: {client_address}")

# Словарь для хранения значений регистров
registers = {
    10071: 0,
    14012: 0,
    21560: 0,
    21561: 0,
    21565: 0,
    21566: 0,
    30023: 0,
    30024: 0,
    30025: 0,
    30026: 0,
    30027: 0,
    30028: 0,
    44883: 0,
    44884: 0,
    44885: 0,
    44886: 0,
    44887: 0,
    44888: 0,
    44889: 0,
    44890: 0
}

try:
    while True:
        # Чтение данных от клиента
        try:
            data = client_socket.recv(1024)

            if not data:
                break
            
            # Обработка запроса клиента
            function_code = struct.unpack('>H', data[7:9])[0]
            print(function_code)
            if function_code == 2:  # Функция чтения дискретных входов
                # Отображение сообщения обмена Modbus на стороне сервера
                print("Получен запрос на чтение дискретных входов от клиента")
                # Адреса, запрашиваемые клиентом
                requested_addresses = struct.unpack('>HH', data[9:13])
                response = b''  # Ответ сервера

                # Формирование ответа на запрос клиента
                for address in range(requested_addresses[0], requested_addresses[1] + 1):
                    if address in registers:
                        response += struct.pack('>B', registers[address])
                    else:
                        response += b'\x00'  # Если адрес не найден, отправляем 0

                # Отправка ответа клиенту
                client_socket.send(response)
            else:
                print("Неизвестная функция Modbus")
        except:...

finally:
    # Закрытие сокета
    client_socket.close()
    server_socket.close()


'''

Адрес: 10071	Функции: 0x2	Описание: Дискретный вход устройства. 
Адрес: 14012	Функции: 0x2	Описание: Дискретный вход устройства. 
Адрес: 14012	Функции: 0x2	Описание: Дискретный вход устройства. 
Адрес: 14012	Функции: 0x2	Описание: Дискретный вход устройства. 
Адрес: 14012	Функции: 0x2	Описание: Дискретный вход устройства. 
Адрес: 21560	Функции: 0x1 0x5 0xF	Описание: Дискретный выход устройства. 
Адрес: 21561	Функции: 0x1 0x5 0xF	Описание: Дискретный выход устройства. 
Адрес: 21565	Функции: 0x1 0x5 0xF	Описание: Дискретный выход устройства. 
Адрес: 21566	Функции: 0x1 0x5 0xF	Описание: Дискретный выход устройства. 
Адрес: 30023,30024	Функции:0x4	Описание: 32-битный вход устройства.  Последовательность байт: 1_0_3_2
Адрес: 30025,30026	Функции:0x4	Описание: 32-битный вход устройства.  Последовательность байт: 1_0_3_2
Адрес: 30027,30028	Функции:0x4	Описание: 32-битный вход устройства.  Последовательность байт: 1_0_3_2
Адрес: 44883,44884	Функции:0x3 0x6 0x10	Описание: 32-битный выход устройства.  Последовательность байт: 1_0_3_2
Адрес: 44885,44886	Функции:0x3 0x6 0x10	Описание: 32-битный выход устройства.  Последовательность байт: 1_0_3_2
Адрес: 44887,44888	Функции:0x3 0x6 0x10	Описание: 32-битный выход устройства.  Последовательность байт: 1_0_3_2
Адрес: 44889,44890	Функции:0x3 0x6 0x10	Описание: 32-битный выход устройства.  Последовательность байт: 1_0_3_2


'''